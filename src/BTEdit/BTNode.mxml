<?xml version="1.0" encoding="utf-8"?>
<s:BorderContainer xmlns:fx="http://ns.adobe.com/mxml/2009"
				   xmlns:s="library://ns.adobe.com/flex/spark"
				   xmlns:mx="library://ns.adobe.com/flex/mx"
				   width="50" height="50" borderVisible="false" initialize="onCreate()"
				   dropShadowVisible="false">
	<fx:Script>
		<![CDATA[
			import behaviorEdit.PathEditPanel;
			
			import emitter.EmitterPanel;
			
			import manager.EventManager;
			import manager.EventType;
			import manager.GameEvent;
			
			import mx.collections.ArrayCollection;
			import mx.controls.HRule;
			import mx.managers.PopUpManager;
			
			import spark.components.Button;
			import spark.components.ComboBox;
			import spark.components.Group;
			import spark.components.Label;
			import spark.components.List;
			import spark.components.RichEditableText;
			import spark.components.TextInput;
			import spark.events.IndexChangeEvent;
			import spark.events.TextOperationEvent;
			import spark.filters.GlowFilter;
			
			private var mCreated:Boolean = false;
			private var mData:Object;
			private var mType:int;
			
			// node vars
			private var mNodeVars:Array = [];
			private var mNodeInputs:Array = [];
			private var mBullets:ArrayCollection;
			
			/** root node, not editable */
			public static const TYPE_ROOT:int = 1;
			/** function node from 6 defined types */
			public static const TYPE_FUNC:int = 3;
			/** editable leaf, only used to mark in node selection ui */
			public static const TYPE_EXEC:int = 4;
						
			public static const FUNC_NODE_EXEC:String = "执行";
			public static const FUNC_NODE_SEQ:String = "顺序";
			public static const FUNC_NODE_PRIO:String = "优先";
			public static const FUNC_NODE_SPAWN:String = "同步";
			public static const FUNC_NODE_COND:String = "条件";
			public static const FUNC_NODE_LOOP:String = "循环";
			public static const FUNC_NODE_ONCE:String = "once";
			public static const FUNC_NODE_EVERY:String = "every";
			public static const FUNC_NODE_RANDOM:String = "随机";
			
			public static const ICON_FUNC_NODE:Object = {
				"执行":BTPanel.ICON_EXEC, 
				"顺序":BTPanel.ICON_SEQ, 
				"优先":BTPanel.ICON_PRIO, 
				"同步":BTPanel.ICON_SPAWN,
				"条件":BTPanel.ICON_COND, 
				"循环":BTPanel.ICON_LOOP,
				"once":BTPanel.ICON_ONCE,
				"every":BTPanel.ICON_EVERY,
				"随机":BTPanel.ICON_RANDOM
			};
			
			private var mChildrens:Vector.<BTNode>;
			private var mParent:BTNode;
			private var mCanvas:BT;
			private var mName:String;
			private var mIsDetached:Boolean = false;
			
			// components
			public var mBtn:Button;
			public var mTitle:Label;
			public var mExecVars:Array = [];
			public var mExecInputs:Array = [];
			public var mNext:Button;
			public var mNextLine:HRule;
			
			private function checkAndCreate(id:String, num:int=0):void {
				switch (id) {
					case "mBtn":
						if (!this.mBtn) {
							this.mBtn = new Button();
							this.mBtn.id = "mBtn"; this.mBtn.width = 50; this.mBtn.height = 50; this.mBtn.setStyle("icon", new BTPanel.ICON_EXEC());
							this.mSubContainer.addElement(this.mBtn);
							
							this.mBtn.addEventListener(MouseEvent.MOUSE_OVER, onMouseOverNode);
							this.mBtn.addEventListener(MouseEvent.MOUSE_OUT, onMouseOutNode);
							this.mBtn.addEventListener(MouseEvent.CLICK, onMouseClickNode);
						}
						break;
					case "mNext":
						if (!this.mNext) {
							this.mNext = new Button();
							this.mNext.id = "mNext"; this.mNext.width = 50; this.mNext.height = 50; this.mNext.setStyle("icon", new BTPanel.ICON_EXEC()); 
							this.mNext.label = "可接节点"; this.mNext.x = 175; this.mNext.y = 0;
							this.addElement(this.mNext);
							
							var menu:ContextMenu = new ContextMenu();
							var item:ContextMenuItem = new ContextMenuItem("更换");
							item.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onPressNext);
							menu.addItem(item);
							item = new ContextMenuItem("粘贴");
							item.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onPasteNodeToNext);
							menu.addItem(item);
							this.mNext.contextMenu = menu;
							
							this.mNext.addEventListener(MouseEvent.ROLL_OVER, onMouseOverNext);
							this.mNext.addEventListener(MouseEvent.ROLL_OUT, onMouseOutNext);
							this.mNext.addEventListener(MouseEvent.CLICK, onPressNext);
							this.mNext.addEventListener(MouseEvent.MIDDLE_CLICK, onPressNext);
						}
						break;
					case "mTitle":
						if (!this.mTitle) {
							this.mTitle = new Label();
							this.mSubContainer.addElement(this.mTitle);
							this.mTitle.percentWidth = 100; this.mTitle.id = "mTitle"; this.mTitle.setStyle("color", "#FFFFFF"); this.mTitle.setStyle("fontSize", 12); 
							this.mTitle.text = "StayOnMap"; this.mTitle.setStyle("textAlign", "center"); this.mTitle.setStyle("verticalAlign", "middle");
						}
						break;
					case "mNextLine":
						if (!this.mNextLine) {
							this.mNextLine = new HRule();
							this.addElement(this.mNextLine);
							this.mNextLine.id = "mNextLine"; this.mNextLine.x = 150; this.mNextLine.y = 25; this.mNextLine.width = 25;
						}
						break;
					case "mVar":
					case "mInput":
						for (var i:int = this.mExecVars.length; i < num; i++) {
							var execVar:Label = new Label();
							execVar.percentWidth = 50; execVar.id = "mVar"+i; this.mTitle.setStyle("color", "#FFFFFF"); this.mTitle.setStyle("fontSize", 14); 
							execVar.text = "variable"; execVar.setStyle("textAlign", "center"); execVar.setStyle("verticalAlign", "middle");
							execVar.y = 30+25*i;
							this.mSubContainer.addElement(execVar);
							this.mExecVars.push(execVar);
							
							if (this.mData.data.execType == "BT.Node.SpawnEmitter") {
								var combo:ComboBox = new ComboBox();
								combo.id = "mInput"+i; combo.x = 60; combo.y = 25*(i+1); combo.percentWidth = 60; combo.setStyle("textAlign", "left");
								this.mSubContainer.addElement(combo);
								this.mExecInputs.push(combo);
								
								this.mBullets = new ArrayCollection();
								var d:Object = Data.getInstance().getBulletsByLevelId(Runtime.getInstance().currentLevelID);
								for (var key:String in d) {
									if (d[key].type == EmitterPanel.PROFILE_EMITTER_TYPE) {
										this.mBullets.addItem(key+":"+d[key].monster_name);
									}
								}
								combo.dataProvider = this.mBullets;
								combo.addEventListener(IndexChangeEvent.CHANGE, onEmitterChanged);
							}
							else if (this.mData.data.execType == "BT.Node.FireBullet" && i == 1) {
								combo = new ComboBox();
								combo.id = "mInput"+i; combo.x = 60; combo.y = 25*(i+1); combo.percentWidth = 60; combo.setStyle("textAlign", "left");
								this.mSubContainer.addElement(combo);
								this.mExecInputs.push(combo);
								
								this.mBullets = new ArrayCollection();
								d = Data.getInstance().getBulletsByLevelId(Runtime.getInstance().currentLevelID);
								for (key in d) {
									if (d[key].type != EmitterPanel.PROFILE_EMITTER_TYPE) {
										this.mBullets.addItem(key+":"+d[key].monster_name);
									}
								}
								combo.dataProvider = this.mBullets;
								combo.addEventListener(IndexChangeEvent.CHANGE, onEmitterChanged);
							}
							else {
								var execInput:TextInput = new TextInput();
								execInput.id = "mInput"+i; execInput.x = 75; execInput.y = 25*(i+1); execInput.percentWidth = 50; execInput.setStyle("textAlign", "center");
								execInput.addEventListener(TextOperationEvent.CHANGE, onValueChanged);
								this.mSubContainer.addElement(execInput);
								this.mExecInputs.push(execInput);
							}
						}
						break;
				}
			}
			
			private function onCreate():void {
				trace("created ");
				this.mCreated = true;
				var menu:ContextMenu = new ContextMenu();
				var item0:ContextMenuItem = new ContextMenuItem("更换");
				item0.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onPressBtn);
				menu.addItem(item0);
				var item:ContextMenuItem = new ContextMenuItem("复制");
				item.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onCopyNode);
				menu.addItem(item);
				item = new ContextMenuItem("粘贴");
				item.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onPasteNode);
				menu.addItem(item);
				item = new ContextMenuItem("剪切");
				item.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onCutNode);
				menu.addItem(item);
				var item1:ContextMenuItem = new ContextMenuItem("删除");
				item1.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onDeleteNode);
				menu.addItem(item1);
				item = new ContextMenuItem("折叠/展开");
				item.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onFoldNode);
				menu.addItem(item);
				this.mSubContainer.contextMenu = menu;
				
				this.mSubContainer.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDownContainer);
				this.mSubContainer.addEventListener(MouseEvent.ROLL_OVER, onMouseOverContainer);
				this.mSubContainer.addEventListener(MouseEvent.ROLL_OUT, onMouseOutContainer);
				
				this.addEventListener(KeyboardEvent.KEY_DOWN, function(evt:KeyboardEvent):void
				{
					evt.stopPropagation();
					evt.stopImmediatePropagation();
				});
				
				if (this.mData) {
					this.updateComponents();
				}
			}
			
			public function getAllChildrens():Array {
				var result:Array = [];
				result.push(this);
				for (var i:int = 0; i < this.mChildrens.length; i++) {
					var r:Array = this.mChildrens[i].getAllChildrens();
					for (var j:int = 0; j < r.length; j++) {
						result.push(r[j]);
					}
				}
				return result;
			}
			
			public var lastMouse:Point;
			private function onMouseDownContainer(event:Event):void {
				if (this.mCanvas.SELECTED_NODE || event.target is RichEditableText) return;
				if (this.mCanvas.CURRENT_EDIT_NODE) {
					this.mCanvas.CURRENT_EDIT_NODE.mSubContainer.filters = [];
				}
				var filter:spark.filters.GlowFilter = new spark.filters.GlowFilter();
				filter.color = 0xFFFF00;
				filter.strength = 50;
				filter.blurX = 20;
				filter.blurY = 20;
				var node:BTNode = this;
				node.mSubContainer.filters = [filter];
				this.mCanvas.CURRENT_EDIT_NODE = node;
				
				if (!this.mParent) return;
				this.mCanvas.DRAGGING_NODES = [node];
				this.mCanvas.DRAGGING_INFOS = [];
				for each (var n:BTNode in this.mCanvas.DRAGGING_NODES) {
					this.mCanvas.DRAGGING_INFOS.push({x:n.x, y:n.y, index:(n.parent as Group).getChildIndex(n)});
					(n.parent as Group).setElementIndex(n, (n.parent as Group).numElements-1);
//					n.alpha = 0.7;
					n.mSubContainer.removeEventListener(MouseEvent.ROLL_OVER, n.onMouseOverContainer);
					n.mSubContainer.removeEventListener(MouseEvent.ROLL_OUT, n.onMouseOutContainer);
					n.mouseChildren = false;
					n.mouseEnabled = false;
				}
				lastMouse = new Point(this.stage.mouseX, this.stage.mouseY);
				this.stage.addEventListener(MouseEvent.MOUSE_UP, onMouseUpStage);
				this.stage.addEventListener(MouseEvent.MOUSE_MOVE, onMouseMoveStage);
			}
			
			private function onMouseMoveStage(event:MouseEvent):void {
				if (!this.stage) return;
				var p:Point = new Point(this.stage.mouseX, this.stage.mouseY);
				for each (var n:BTNode in this.mCanvas.DRAGGING_NODES) {
					n.x += p.x - lastMouse.x;
					n.y += p.y - lastMouse.y;
				}
				lastMouse = p;
			}
			
			private function onMouseUpStage(event:Event):void {
				this.stage.removeEventListener(MouseEvent.MOUSE_UP, onMouseUpStage);
				this.stage.removeEventListener(MouseEvent.MOUSE_MOVE, onMouseMoveStage);
				var i:int = 0;
				for each (var n:BTNode in this.mCanvas.DRAGGING_NODES) {
					n.stopDrag();
//					n.alpha = 1;
					n.x = this.mCanvas.DRAGGING_INFOS[i].x;
					n.y = this.mCanvas.DRAGGING_INFOS[i].y;
					(n.parent as Group).setElementIndex(n, this.mCanvas.DRAGGING_INFOS[i].index);
					n.mSubContainer.addEventListener(MouseEvent.ROLL_OVER, n.onMouseOverContainer);
					n.mSubContainer.addEventListener(MouseEvent.ROLL_OUT, n.onMouseOutContainer);
					n.mouseChildren = true;
					n.mouseEnabled = true;
					i++;
				}
				var srcNode:BTNode = this.mCanvas.DRAGGING_NODES[0];
				var dstNode:BTNode = this.mCanvas.TARGET_NODE;
				if (this.mCanvas.TARGET_NODE && this.mCanvas.TARGET_TYPE == 1) {
					srcNode.mSubContainer.filters = [];
					dstNode.mSubContainer.filters = [];
					var p1:BTNode = srcNode.nodeParent;
					var p2:BTNode = dstNode.nodeParent;
					var index1:int = p1.nodeChildrens.indexOf(srcNode);
					var index2:int = p2.nodeChildrens.indexOf(dstNode);
					p1.removeChildNode(srcNode);
					p2.removeChildNode(dstNode);
					if (index1 < index2) {
						p1.insertChildNodeAt(dstNode, index1);
						p2.insertChildNodeAt(srcNode, index2);
					}
					else {
						p2.insertChildNodeAt(srcNode, index2);
						p1.insertChildNodeAt(dstNode, index1);
					}
					p1.updateComponents();
					p2.updateComponents();
					this.mCanvas.autoLayout();
				}
				else if (this.mCanvas.TARGET_NODE && this.mCanvas.TARGET_TYPE == 2) {
					dstNode.mNext.filters = [];
					p1 = srcNode.nodeParent;
					p1.removeChildNode(srcNode);
					p1.updateComponents();
					dstNode.insertChildNodeAt(srcNode, 0);
					dstNode.updateComponents();
					this.mCanvas.autoLayout();
				}
				this.mCanvas.setModified(true);
				this.mCanvas.TARGET_NODE = null;
				this.mCanvas.DRAGGING_NODES = null;
				this.mCanvas.DRAGGING_INFOS = null;
			}
			
			public function onMouseOverContainer(event:Event):void {
				if (this.mCanvas.DRAGGING_NODES && this.mCanvas.DRAGGING_NODES[0] != this 
					&& !this.containsChild(this.mCanvas.DRAGGING_NODES[0]) && !this.mCanvas.DRAGGING_NODES[0].containsChild(this)) {
					var filter:spark.filters.GlowFilter = new spark.filters.GlowFilter();
					filter.color = 0x00FF00;
					filter.strength = 50;
					filter.blurX = 20;
					filter.blurY = 20;
					this.mSubContainer.filters = [filter];
					this.mCanvas.TARGET_NODE = this;
					this.mCanvas.TARGET_TYPE = 1;
				}
			}
			
			public function onMouseOutContainer(event:Event):void {
				if (this.mCanvas.DRAGGING_NODES && this.mCanvas.DRAGGING_NODES[0] != this
					&& !this.containsChild(this.mCanvas.DRAGGING_NODES[0]) && !this.mCanvas.DRAGGING_NODES[0].containsChild(this)) {
					this.mSubContainer.filters = [];
					this.mCanvas.TARGET_NODE = null;
				}
			}
			
			private function onMouseOverNext(event:Event):void {
				if (this.isFolded()) return;
				if (this.mCanvas.DRAGGING_NODES) {
					var filter:spark.filters.GlowFilter = new spark.filters.GlowFilter();
					filter.color = 0x00FF00;
					filter.strength = 50;
					filter.blurX = 20;
					filter.blurY = 20;
					this.mNext.filters = [filter];
					this.mCanvas.TARGET_NODE = this;
					this.mCanvas.TARGET_TYPE = 2;
				}
			}
			
			private function onMouseOutNext(event:Event):void {
				if (this.isFolded()) return;
				if (this.mCanvas.DRAGGING_NODES) {
					this.mNext.filters = [];
					this.mCanvas.TARGET_NODE = null;
				}
			}
			
			private function onInput1Click(event:Event):void {
				var id:String = event.currentTarget.id;
				var index:int = Utils.getLastInt(id);
				var data:Object = this.mData.data.parm[index];
				
				var window:PathEditPanel = new PathEditPanel(name, data.path, data.type=="array_ccp_curve");
				
				window.addEventListener(MsgEvent.EDIT_PATH, onPathEditPanelClose);
				PopUpManager.addPopUp(window, MapEditor.getInstance(), true);
				PopUpManager.centerPopUp(window);
			}
			
			private function onPathEditPanelClose(e:MsgEvent):void {
				for (var i:int = 0; i < this.mExecVars.length; i++) {
					if (this.mExecVars[i].text == "path") {
						break;
					}
				}
				this.mExecInputs[i].text =  JSON.stringify(e.hintData);
				this.mData.data.parm[i].path = e.hintData;
				this.writeDataBackToParent();
				this.mCanvas.setModified(true);
			}
			
			private function onMouseOverNode(event:Event):void {
				if (this.mCanvas.SELECTED_NODE) {
					var filter:spark.filters.GlowFilter = new spark.filters.GlowFilter();
					filter.color = 0x00FF00;
					filter.strength = 50;
					filter.blurX = 20;
					filter.blurY = 20;
					this.mBtn.filters = [filter];
				}
			}
			
			private function onMouseOutNode(event:Event):void {
				if (this.mCanvas.SELECTED_NODE) {
					this.mBtn.filters = [];
				}
			}
			
			private function onMouseClickNode(event:Event):void {
				if (this.mCanvas.SELECTED_NODE) {
					var data:Object = {type:this.mCanvas.SELECTED_NODE, data:null, children:[]};
					if (this.mCanvas.SELECTED_NODE == FUNC_NODE_LOOP) {
						data.times = 1;
					}					
					else if (this.mCanvas.SELECTED_NODE == FUNC_NODE_EVERY) {
						data.interval = 0.5;
						data.skip = 0;
					}
					else if (this.mCanvas.SELECTED_NODE == FUNC_NODE_RANDOM) {
						data.weights = [];
					}
					if (this.type == TYPE_ROOT) {
						if (!this.mData.children || this.mData.children.length < 1) {
							this.mData = data;
						}
						else {
							this.mData.children.push(data);
						}
						this.clearChildrens();
					}
					else {
						if (!this.mData.children) {
							this.mData.children = [data];
						}
						else {
							this.mData.children.push(data);
						}
						this.writeDataBackToParent();
					}
					this.addChildNodeWithData(data);
					this.mCanvas.autoLayout();
					this.mCanvas.clearSelected();
					this.mCanvas.setModified(true);
					this.mBtn.filters = [];
				}
			}
			
			public function onCopyNode(event:Event=null):void {
				trace(JSON.stringify(this.rootNode.nodeData));
				BTPanel.CLIPPING = Utils.cloneObjectData(this.mData);
				trace("clipping data "+JSON.stringify(this.mData));
			}
			
			public function onDeleteNode(event:Event=null):void {
				this.clearChildrens();
				if (this.mParent) {
					this.mCanvas.removeNodeFromCanvas(this);
					if (this.mParent.type == TYPE_ROOT && this.mParent.nodeChildrens.length == 1) {
						this.mParent.nodeData = {type:"执行", children:[], data:null};
						this.mCanvas.updateTree(true);
					}
					else {
						var index:int = this.mParent.nodeChildrens.indexOf(this);
						this.mParent.nodeChildrens.splice(index, 1);
						this.mParent.nodeData.children.splice(index, 1);
						this.mParent.writeDataBackToParent();
						this.mParent.updateComponents();
						this.mCanvas.autoLayout();
					}
				}
				else {
					this.mData = {type:"执行", children:[], data:null};
					this.mCanvas.updateTree(true);
				}
				this.mCanvas.setModified(true);
			}
			
			private function onFoldNode(event:Event):void {
				if (!this.mData.children || this.mData.children.length == 0 || this.type == TYPE_ROOT) {
					return;
				}
				if (!this.isFolded()) {
					this.mData.fold = true;
				}
				else {
					this.mData.fold = false;
				}
				this.writeDataBackToParent();
				this.mCanvas.setModified(true);
				this.updateComponents();
				this.mCanvas.autoLayout();
			}
			
			public function onPasteNode(event:Event=null):void {
				if (BTPanel.CLIPPING) {
					var clipping:Object = Utils.cloneObjectData(BTPanel.CLIPPING);
					this.mCanvas.setModified(true);
					if (!this.mParent) {
						this.mData = clipping;
						this.mCanvas.updateTree(true);
					}
					else {
						if (this.mParent.type == TYPE_ROOT) {
							this.mParent.nodeData = clipping;
							this.mCanvas.updateTree(true);
						}
						else {
							var index:int = this.mParent.mChildrens.indexOf(this);
							this.mParent.nodeData.children[index] = clipping;
							this.setData(TYPE_FUNC, clipping.type, clipping, this.mCanvas, this.mParent);
							this.updateChildrens();
							this.mCanvas.autoLayout();
						}
					}
				}
			}
			
			public function onCutNode(event:Event=null):void {
				this.onCopyNode(event);
				this.onDeleteNode(event);
			}
			
			private function onPasteNodeToNext(event:Event):void {
				if (this.isFolded()) return;
				if (BTPanel.CLIPPING) {
					var clipping:Object = Utils.cloneObjectData(BTPanel.CLIPPING);
					if (this.type == TYPE_ROOT) {
						this.mData = clipping;
						this.mCanvas.updateTree(true);
					}
					else {
						this.mData.children.push(clipping);
						this.writeDataBackToParent();
						this.addChildNodeWithData(clipping);
						this.mCanvas.autoLayout();
					}
					this.mCanvas.setModified(true);
				}
			}
			
			public function setData(type:int, name:String, data:Object, canvas:BT, parent:BTNode=null):void {
				this.mType = type;
				this.mData = data;
				this.mCanvas = canvas;
				this.mParent = parent;
				this.mName = name;
				
				if (this.mCreated) {
					this.updateComponents();
				}
				this.updateChildrens();
			}
			
			public function updateComponents():void {
//				trace("name "+this.mName+" depth "+this.nodeDepth+" siblingIndex "+this.siblingIndex);
				var i:int;
				var j:int;
				var hasNextNode:Boolean = false;
				var numParams:int;
				this.toolTip = "";
				for (i = 0; i < this.mNodeVars.length; i++) {
					this.removeElement(this.mNodeVars[i]);
					this.removeElement(this.mNodeInputs[i]);
					this.mNodeInputs[i].removeEventListener(TextOperationEvent.CHANGE, onValueChanged);
				}
				this.mNodeVars.length = 0;
				this.mNodeInputs.length = 0;
				
				this.checkAndCreate("mBtn");
				this.checkAndCreate("mNext");
				this.checkAndCreate("mNextLine");
				switch (this.mType) {
					case TYPE_ROOT:
						this.mBtn.visible = true;
						this.mBtn.setStyle("icon", new BTPanel.ICON_ROOT());
						this.mSubContainer.width = this.mSubContainer.height = 50;
						for (i = 0; i < this.mExecVars.length; i++) {
							this.mExecVars[i].visible = false;
							this.mExecInputs[i].visible = false;
						}
						if (this.isFolded()) {
							this.mNextLine.visible = true;
							this.mNext.visible = true;
							this.mNextLine.x = 50;
							this.mNext.x = 75;
							this.mNext.setStyle("icon", new BTPanel.ICON_FOLD());
						}
						else {
							this.mNextLine.visible = false;
							this.mNext.visible = false;
						}
						break;
					case TYPE_FUNC:
						this.checkAndCreate("mTitle");
						if (this.mName == FUNC_NODE_EXEC) {
							// empty node
							if (this.mData.args || !this.mData.data) {
								this.mBtn.visible = true;
								this.mBtn.setStyle("icon", new ICON_FUNC_NODE[this.mName]());
								this.mSubContainer.width = this.mSubContainer.height = 50;
								for (i = 0; i < this.mExecVars.length; i++) {
									this.mExecVars[i].visible = false;
									this.mExecInputs[i].visible = false;
								}
								this.mTitle.visible = false;
								this.mNext.visible = false;
								this.mNextLine.visible = false;
								if (this.isFolded()) {
									this.mNextLine.visible = true;
									this.mNext.visible = true;
									this.mNextLine.x = 50;
									this.mNext.x = 75;
									this.mNext.setStyle("icon", new BTPanel.ICON_FOLD());
								}
								else {
									this.mNext.visible = false;
									this.mNextLine.visible = false;
								}
							}
							// contains children, replace it
							else {
								for each (var d:Object in Data.getInstance().behaviorNodes) {
									if (d.func == this.mData.data.execType) {
										this.toolTip = d.desc;
										break;
									}
								}
								this.mBtn.visible = false;
								this.mTitle.visible = true;
								this.mTitle.text = this.mData.data.execType.substr(8);
								hasNextNode = false;
								j = 1;
								for (i = 0; i < this.mData.data.parm.length; i++) {
									if (this.mData.data.parm[i].type == "node") {
										hasNextNode = true;
									}
									else {
										this.checkAndCreate("mVar", j);
										this.mExecVars[j-1].visible = true;
										this.mExecInputs[j-1].visible = true;
										this.mExecVars[j-1].text = this.mData.data.parm[i].name;
										if (this.mExecInputs[j-1] is TextInput) {
											this.mExecInputs[j-1].text = this.mData.data.parm[i].value || JSON.stringify(this.mData.data.parm[i].path);
											if (this.mData.data.parm[i].path) {
												this.mExecInputs[j-1].addEventListener(MouseEvent.CLICK, onInput1Click);
											}
											else {
												this.mExecInputs[j-1].removeEventListener(MouseEvent.CLICK, onInput1Click);
											}
										}
										else {
											for (var k:int = 0; k < this.mBullets.length; k++) {
												if ((this.mBullets.getItemAt(k) as String).indexOf(this.mData.data.parm[i].value) == 0) break;
											}
											if (this.mBullets.length > 0) {
												this.mExecInputs[j-1].selectedIndex = k;
											}
										}
										j++;
									}
								}
								numParams = j;
								for (; j <= this.mExecVars.length; j++) {
									this.mExecVars[j-1].visible = false;
									this.mExecInputs[j-1].visible = false;
								}
								if (this.isFolded()) {
									this.mNextLine.visible = true;
									this.mNext.visible = true;
									this.mNextLine.x = 150;
									this.mNext.x = 175;
									this.mNext.setStyle("icon", new BTPanel.ICON_FOLD());
								}
								else if (hasNextNode && (!this.mData.children || this.mData.children.length < 1)) {
									this.mNext.visible = true;
									this.mNextLine.visible = true;
									this.mNextLine.x = 150;
									this.mNext.x = 175;
									this.mNext.setStyle("icon", new BTPanel.ICON_EXEC());
								}
								else {
									this.mNext.visible = false;
									this.mNextLine.visible = false;
								}
								this.mSubContainer.width = 150;
								numParams = numParams<2?2:numParams;
								this.mSubContainer.height = 60+(numParams-2)*25;
							}
						}
						else {
							if (this.mName == FUNC_NODE_LOOP) {
								var label:Label = new Label();
								this.addElement(label);
								label.id = "mNodeVar1"; label.x = -25; label.y = 55; label.width = 50; label.text = "loop";
								label.setStyle("fontSize", 14); label.setStyle("textAlign", "right"); label.setStyle("verticalAlign", "middle");
								this.mNodeVars.push(label);
								var input:TextInput = new TextInput();
								this.addElement(input);
								input.id = "mNodeInput1"; input.x = 25; input.y = 52; input.width = 40; input.height = 18;
								input.setStyle("fontSize", 11); input.setStyle("textAlign", "center");
								this.mNodeInputs.push(input);
								input.addEventListener(TextOperationEvent.CHANGE, onValueChanged);
								if (this.mData.times) {
									input.text = this.mData.times;
								}
							}
							else if (this.mName == FUNC_NODE_EVERY) {
								label = new Label();
								this.addElement(label);
								label.id = "mNodeVar1"; label.x = -25; label.y = 55; label.width = 50; label.text = "inteval";
								label.setStyle("fontSize", 14); label.setStyle("textAlign", "right"); label.setStyle("verticalAlign", "middle");
								this.mNodeVars.push(label);
								input = new TextInput();
								this.addElement(input);
								input.id = "mNodeInput1"; input.x = 25; input.y = 52; input.width = 40; input.height = 18;
								input.setStyle("fontSize", 11); input.setStyle("textAlign", "center");
								this.mNodeInputs.push(input);
								input.addEventListener(TextOperationEvent.CHANGE, onValueChanged);
								if (this.mData.interval) {
									input.text = this.mData.interval;
								}
								
								label = new Label();
								this.addElement(label);
								label.id = "mNodeVar2"; label.x = -25; label.y = 75; label.width = 50; label.text = "skip";
								label.setStyle("fontSize", 14); label.setStyle("textAlign", "right"); label.setStyle("verticalAlign", "middle");
								this.mNodeVars.push(label);
								input = new TextInput();
								this.addElement(input);
								input.id = "mNodeInput2"; input.x = 25; input.y = 72; input.width = 40; input.height = 18;
								input.setStyle("fontSize", 11); input.setStyle("textAlign", "center");
								this.mNodeInputs.push(input);
								input.addEventListener(TextOperationEvent.CHANGE, onValueChanged);
								if (this.mData.hasOwnProperty("skip")) {
									input.text = this.mData.skip;
								}
							}
							else if (this.mName == FUNC_NODE_RANDOM) {
								for (i = 0; i < this.mData.children.length; i++) {
									label = new Label();
									this.addElement(label);
									label.id = "mNodeVar"+(i+1); label.x = -25; label.y = 55+i*20; label.width = 50; label.text = "weight"; 
									label.setStyle("fontSize", 14); label.setStyle("textAlign", "right"); label.setStyle("verticalAlign", "middle");
									this.mNodeVars.push(label);
									input = new TextInput();
									this.addElement(input);
									input.id = "mNodeInput"+(i+1); input.x = 25; input.y = 52+i*20; input.width = 40; input.height = 18;
									input.setStyle("fontSize", 11); input.setStyle("textAlign", "center");
									this.mNodeInputs.push(input);
									input.addEventListener(TextOperationEvent.CHANGE, onValueChanged);
									if (this.mData.weights.length > i) {
										input.text = this.mData.weights[i];
									}
								}
							}
							
							this.mBtn.visible = true;
							this.mBtn.setStyle("icon", new ICON_FUNC_NODE[this.mName]());
							this.mSubContainer.width = this.mSubContainer.height = 50;
							for (i = 0; i < this.mExecVars.length; i++) {
								this.mExecVars[i].visible = false;
								this.mExecInputs[i].visible = false;
							}
							if (this.isFolded()) {
								this.mNextLine.visible = true;
								this.mNext.visible = true;
								this.mNextLine.x = 50;
								this.mNext.x = 75;
								this.mNext.setStyle("icon", new BTPanel.ICON_FOLD());
							}
							else {
								this.mNext.visible = false;
								this.mNextLine.visible = false;
							}
							this.mTitle.visible = false;
						}
						break;
				}
			}
			
			public function clearChildrens():void {
				if (this.mChildrens) {
					for (var i:int = 0; i < this.mChildrens.length; i++) {
						this.mChildrens[i].mCanvas.removeNodeFromCanvas(this.mChildrens[i]);
						this.mChildrens[i].clearChildrens();
					}
				}
				else {
					this.mChildrens = new Vector.<BTNode>();
				}
				this.mChildrens.length = 0;
			}
			
			private function updateChildrens():void {
				this.clearChildrens();
				var child:BTNode;
				switch (this.mType) {
					case TYPE_ROOT:
						if (this.mData.type) {
							this.addChildNodeWithData(this.mData);
						}
						break;
					case TYPE_FUNC:
						for each (var data:Object in this.mData.children) {
							this.addChildNodeWithData(data);
						}
						break;
				}
			}
			
			private function addChildNodeWithData(data:Object):void {
				var child:BTNode = BT.POOL_POP();
				this.mChildrens.push(child);
				child.setData(TYPE_FUNC, data.type, data, this.mCanvas, this);
				this.mCanvas.addNodeToCanvas(child);
			}
			
			private function removeChildNode(node:BTNode):void {
				var index:int = this.mChildrens.indexOf(node);
				if (index >= 0) {
					node.mParent = null;
					this.mData.children.splice(index, 1);
					this.mChildrens.splice(index, 1);
				}
			}
			
			private function insertChildNodeAt(node:BTNode, index:int):void {
				node.nodeParent = this;
				this.mChildrens.splice(index, 0, node);
				this.mData.children.splice(index, 0, node.nodeData);
				node.writeDataBackToParent();
			}
			
			private function onBtnIconLoad(event:Event):void {
				var bmpData:BitmapData = event.currentTarget.content.bitmapData;
				this.mBtn.setStyle("icon", bmpData);
			}
			
			private function onPressBtn(event:Event):void {
				if (this.mType == TYPE_ROOT) return;

				EventManager.getInstance().addEventListener(EventType.BT_NODE_SELECTION_COMPLETE, onNodeSelected);
				var selection:BTNodeSelection = new BTNodeSelection();
				PopUpManager.addPopUp(selection, MapEditor.getInstance(), true);
				PopUpManager.centerPopUp(selection);
			}
			
			private function onNodeSelected(event:GameEvent):void {
				EventManager.getInstance().removeEventListener(EventType.BT_NODE_SELECTION_COMPLETE, onNodeSelected);
				if (!event.data) return;
				
				// change current node
				var newData:Object;
				switch (event.data.type) {
					case TYPE_EXEC:
//						if (this.isSubBT) {
							this.clearChildrens();
							this.mData.children = [];
//						}
						newData = {type:"执行", children:this.mData.children, data:{execType:event.data.name.func, parm:[]}};
						for (var i:int = 0; i < event.data.name.args.length; i++) {
							if (event.data.name.args[i].type == "ccp") {
								newData.data.parm.push({type:"ccp", name:"x", value:"float"});
								newData.data.parm.push({type:"ccp", name:"y", value:"float"});
							}
							else if (event.data.name.args[i].type == "ccsize") {
								newData.data.parm.push({type:"ccsize", name:"width", value:"float"});
								newData.data.parm.push({type:"ccsize", name:"height", value:"float"});
							}
							else {
								if (event.data.name.args[i].name == "path") {
									event.data.name.args[i].path = [];
								}
								else {
									event.data.name.args[i].value = event.data.name.args[i].type;
								}
								newData.data.parm.push(event.data.name.args[i]);
							}
						}
						this.mType = TYPE_FUNC;
						this.mName = FUNC_NODE_EXEC;
						this.mData = newData;
						// clear exec vars & inputs
						for (i = 0; i < this.mExecVars.length; i++) {
							this.mSubContainer.removeElement(this.mExecVars[i]);
							if (this.mExecInputs[i] is TextInput) {
								this.mExecInputs[i].removeEventListener(TextOperationEvent.CHANGE, onValueChanged);
							}
							else {
								this.mExecInputs[i].removeEventListener(IndexChangeEvent.CHANGE, onEmitterChanged);
							}
							this.mSubContainer.removeElement(this.mExecInputs[i]);
						}
						this.mExecVars.length = 0;
						this.mExecInputs.length = 0;
						break;
					case TYPE_FUNC:
						newData = {type:event.data.name, data:null, children:this.mData.children};
						if (event.data.name == FUNC_NODE_LOOP) {
							newData.times = 1;
						}
						else if (event.data.name == FUNC_NODE_EVERY) {
							newData.interval = 0.5;
							newData.skip = 0;
						}
						else if (event.data.name == FUNC_NODE_RANDOM) {
							newData.weights = [];
							for (i = 0; i < this.mData.children.length; i++) {
								newData.weights.push(1);
							}
						}
						this.mType = TYPE_FUNC;
						this.mName = event.data.name;
						this.mData = newData;
						break;
				}
				this.writeDataBackToParent();
				this.mCanvas.setModified(true);
				this.updateComponents();
				this.mCanvas.autoLayout();
			}
			
			public function writeDataBackToParent():void {
				if (this.mName == FUNC_NODE_RANDOM) {
					for (var i:int = 0; i < this.mData.children.length; i++) {
						if (this.mData.weights.length <= i) {
							this.mData.weights.push(1);
						}
					}
				}
				if (this.mParent) {
					if (this.mParent.type != TYPE_ROOT) {
						var index:int = this.mParent.nodeChildrens.indexOf(this);
						this.mParent.nodeData.children[index] = this.mData;
						this.mParent.writeDataBackToParent();
					}
					else {
						this.mParent.nodeData = this.mData;
					}
				}
				else {
					this.mCanvas.data[0] = this.mData;
				}
			}
			
			private function onPressNext(event:Event):void {
				if (this.isFolded()) {
					this.onFoldNode(event);
					return;
				}
				
				EventManager.getInstance().addEventListener(EventType.BT_NODE_SELECTION_COMPLETE, onNextNodeSelected);
				var selection:BTNodeSelection = new BTNodeSelection();
				PopUpManager.addPopUp(selection, MapEditor.getInstance(), true);
				PopUpManager.centerPopUp(selection);
			}
			
			private function onNextNodeSelected(event:GameEvent):void {
				EventManager.getInstance().removeEventListener(EventType.BT_NODE_SELECTION_COMPLETE, onNextNodeSelected);
				if (!event.data) return;
				
				this.mData.children = [];
				var newData:Object;
				switch (event.data.type) {
					case TYPE_EXEC:
						newData = {type:"执行", children:[], data:{execType:event.data.name.func, parm:[]}};
						for (var i:int = 0; i < event.data.name.args.length; i++) {
							if (event.data.name.args[i].type == "ccp") {
								newData.data.parm.push({type:"ccp", name:"dir x", value:"float"});
								newData.data.parm.push({type:"ccp", name:"dir y", value:"float"});
							}
							else if (event.data.name.args[i].type == "ccsize") {
								newData.data.parm.push({type:"ccsize", name:"width", value:"float"});
								newData.data.parm.push({type:"ccsize", name:"height", value:"float"});
							}
							else {
								if (event.data.name.args[i].name == "path") {
									event.data.name.args[i].path = [];
								}
								else {
									event.data.name.args[i].value = event.data.name.args[i].type;
								}
								newData.data.parm.push(event.data.name.args[i]);
							}
						}
						if (this.type == TYPE_ROOT) {
							this.mData = newData;
						}
						else {
							this.mData.children.push(newData);
						}
						break;
					case TYPE_FUNC:
						newData = {type:event.data.name, data:null, children:[]};
						if (event.data.name == FUNC_NODE_LOOP) {
							newData.times = 1;
						}
						else if (event.data.name == FUNC_NODE_EVERY) {
							newData.interval = 0.5;
							newData.skip = 0;
						}
						else if (event.data.name == FUNC_NODE_RANDOM) {
							newData.weights = [];
							for (i = 0; i < this.mData.children.length; i++) {
								newData.weights.push(1);
							}
						}
						if (this.type == TYPE_ROOT) {
							this.mData = newData;
						}
						else {
							this.mData.children.push(newData);
						}
						break;
				}
				this.writeDataBackToParent();
				this.mCanvas.setModified(true);
				this.updateComponents();
				this.addChildNodeWithData(newData);
				this.mCanvas.autoLayout();
			}
			
			private function onValueChanged(event:TextOperationEvent):void {
				var id:String = event.currentTarget.id;
				if (id.indexOf("mNodeInput") != -1) {
					if (this.mName == FUNC_NODE_LOOP) {
						this.mData.times = (event.currentTarget as TextInput).text;
					}
					else if (this.mName == FUNC_NODE_EVERY) {
						if (id == "mNodeInput1") {
							this.mData.interval = (event.currentTarget as TextInput).text;
						}
						else if (id == "mNodeInput2") {
							this.mData.skip = (event.currentTarget as TextInput).text;
						}
					}
					else if (this.mName == FUNC_NODE_RANDOM) {
						var index:int = Utils.getLastInt(id);
						this.mData.weights[index-1] = (event.currentTarget as TextInput).text;
					}
				}
				else {
					index = Utils.getLastInt(id);
					this.mData.data.parm[index].value = (event.currentTarget as TextInput).text;
				}
				this.writeDataBackToParent();
				this.mCanvas.setModified(true);
			}
			
			private function onEmitterChanged(event:IndexChangeEvent):void {
				var id:String = event.currentTarget.id;
				var index:int = Utils.getLastInt(id);
				var text:String = this.mBullets.getItemAt((event.currentTarget as ComboBox).selectedIndex) as String;
				this.mData.data.parm[index].value = text.substr(0, text.indexOf(":"));
				this.writeDataBackToParent();
				this.mCanvas.setModified(true);
			}
			
			public function reset():void {

			}
			
			private static const DICT:Object = {float:"数字", int:"整数", node:"节点", array_string:"字符串数组", ccp:"数字", string:"字符串", array_ccp:"point数组"};
			public function validate():Object {
				if (this.mType != TYPE_ROOT && this.mData && this.mData.data && this.mData.data.parm) {
					var params:Array = this.mData.data.parm;
					var execPointer:int = 0;
					for (var i:int = 0; i < params.length; i++) {
						switch (params[i].type) {
							case "float":
								var v:String = (this.mExecInputs[execPointer] as TextInput).text;
								if (v.length < 1) return {result:false, expect:DICT["float"], input:v, name:this.mData.data.execType, field:params[i].name};
								var n:Number = Number(v);
								execPointer++;
								if (isNaN(n)) return {result:false, expect:DICT["float"], input:v, name:this.mData.data.execType, field:params[i].name};
								break;
							case "int":
								v = (this.mExecInputs[execPointer] as TextInput).text;
								if (v.length < 1 || (v.charAt(0) < "0" || v.charAt(0) > "9")) return {result:false, expect:DICT["int"], input:v, name:this.mData.data.execType, field:params[i].name};
								var vInt:int = parseInt(v, 10);
								execPointer++;
								if (isNaN(vInt)) return {result:false, expect:DICT["int"], input:v, name:this.mData.data.execType, field:params[i].name};
								break;
							case "node":
								break;
							case "array_string":
								execPointer++;
								break;
							case "ccp":
								v = (this.mExecInputs[execPointer] as TextInput).text;
								if (v.length < 1) return {result:false, expect:DICT["ccp"], input:v, name:this.mData.data.execType, field:params[i].name};
								n = Number(v);
								execPointer++;
								if (isNaN(n)) return {result:false, expect:DICT["ccp"], input:v, name:this.mData.data.execType, field:params[i].name};
								v = (this.mExecInputs[execPointer] as TextInput).text;
								if (v.length < 1) return {result:false, expect:DICT["ccp"], input:v, name:this.mData.data.execType, field:params[i+1].name};
								n = Number(v);
								execPointer++;
								if (isNaN(n)) return {result:false, expect:DICT["ccp"], input:v, name:this.mData.data.execType, field:params[i+1].name};
								i++;
								break;
							case "string":
								execPointer++;
								break;
							case "array_ccp":
								v = (this.mExecInputs[execPointer] as TextInput).text;
								var o:Object;
								try {
									o = JSON.parse(v);
									if (!(o is Array)) return {result:false, expect:DICT["array_ccp"], input:v, name:this.mData.data.execType, field:params[i].name};
									for (var j:int = 0; j < o.length; j++) {
										if (!o[j].hasOwnProperty("x") || !o[j].hasOwnProperty("y")) {
											return {result:false, expect:DICT["array_ccp"], input:v, name:this.mData.data.execType, field:params[i].name};
										}
										if (!(o[j].x is Number && o[j].y is Number)) {
											return {result:false, expect:DICT["array_ccp"], input:v, name:this.mData.data.execType, field:params[i].name};
										}
									}
								}
								catch (e:Error) {
									return {result:false, expect:DICT["array_ccp"], input:v, name:this.mData.data.execType, field:params[i].name};
								}
								execPointer++;
								break;
						}
					}
				}
				else if (this.mName == FUNC_NODE_LOOP || this.mName == FUNC_NODE_RANDOM || this.mName == FUNC_NODE_EVERY) {
					for (i = 0; i < this.mNodeInputs.length; i++) {
						v = (this.mNodeInputs[i] as TextInput).text;
						if (v.length < 1) return {result:false, expect:DICT["float"], input:v, name:this.mName, field:this.mNodeVars[i].text};
						n = Number(v);
						if (isNaN(n)) return {result:false, expect:DICT["float"], input:v, name:this.mName, field:this.mNodeVars[i].text};
					}
				}
				return {result:true};
			}
			
			public function get isInFoldedTree():Boolean {
				if (this.mParent && this.mParent.isFolded() && this.mParent.nodeParent) {
					return true;
				}
				if (!this.mParent) {
					return false;
				}
				return this.mParent.isInFoldedTree;
			}
			
			public function isFolded():Boolean {
				if (this.mData.fold) return true;
				return false;
			}
			
			public function containsChild(node:BTNode):Boolean {
				if (this == node) return true;
				for each (var child:BTNode in this.mChildrens) {
					if (child == node) return true;
					var r:Boolean = child.containsChild(node);
					if (r) return r;
				}
				return false;
			}
			
			public function checkNearestRootNode(node:BTNode):BTNode {
				if (this == node) return this;
				var node1:BTNode;
				var node2:BTNode;
				var depth1:int = this.nodeDepth;
				var depth2:int = node.nodeDepth;
				if (depth1 <= depth2) {
					node1 = this;
					node2 = node;
				}
				else {
					node1 = node;
					node2 = this;
					var tmp:int = depth1;
					depth1 = depth2;
					depth2 = tmp;
				}
				while (depth2 > depth1) {
					node2 = node2.nodeParent;
					depth2--;
				}
				if (node2 == node1) return node2;
				else {
					node2 = node2.nodeParent;
					node1 = node1.nodeParent;
					if (node2 == node1) return node2;
				}
				return null;
			}
			
			public function get nodeDepth():int {
				var depth:int = 0;
				var p:BTNode = this.mParent;
				while (p) {
					depth++;
					p = p.nodeParent;
				}
				return depth;
			}
			
			public function get siblingIndex():int {
				if (this.mParent) { 
					var index:int = this.mParent.nodeChildrens.indexOf(this);
					if (index <= 0) {
						return this.mParent.siblingIndex;
					}
					else {
						return this.mParent.nodeChildrens[index-1].maxSiblings + this.mParent.nodeChildrens[index-1].siblingIndex;
					}
				}
				return 0;
			}
			
			/** max depth count from current node */
			public function get maxDepth():int {
				if (this.mChildrens.length <= 0) return 1;
				var max:int = 1;
				for (var i:int = 0; i < this.mChildrens.length; i++) {
					var depth:int = this.mChildrens[i].maxDepth;
					if (depth > max) {
						max = depth;
					}
				}
				return max+1;
			}
			
			public function get maxSiblings():int {
				if (!this.mChildrens || this.mChildrens.length <= 0) return 1;
				var max:int = 0;
				for (var i:int = 0; i < this.mChildrens.length; i++) {
					var s:int = this.mChildrens[i].maxSiblings;
					max += s;
				}
				return max;
			}
			
			public function get rootNode():BTNode {
				if (this.mParent) {
					return this.mParent.rootNode;
				}
				return this;
			}
			
			public function get nodeWidth():Number {
//				if (this.mName == FUNC_NODE_LOOP || this.mName == FUNC_NODE_EVERY || this.mName == FUNC_NODE_RANDOM) {
//					return this.mSubContainer.width+20;
//				}
				return this.mSubContainer.width;
			}
			
			public function get nodeHeight():Number {
				if (this.mName == FUNC_NODE_LOOP) {
					return this.mSubContainer.height+20;
				}
				else if (this.mName == FUNC_NODE_EVERY) {
					return this.mSubContainer.height+40;
				}
				else if (this.mName == FUNC_NODE_RANDOM) {
					return this.mSubContainer.height+20*this.mData.weights.length;
				}
				return this.mSubContainer.height;
			}
			
			public function get type():int { return this.mType; }
			public function get nodeParent():BTNode { return this.mParent; }
			public function set nodeParent(value:BTNode):void { this.mParent = value; }
			public function get nodeChildrens():Vector.<BTNode> { return this.mChildrens; }
			public function get nodeName():String { return this.mName; }
			public function set nodeName(value:String):void { this.mName = value; }
			public function get nodeData():Object { return this.mData; }
			public function set nodeData(value:Object):void { this.mData = value; }
			public function get isDetached():Boolean { return this.mIsDetached};
			public function set isDetached(value:Boolean):void { this.isDetached = value; }
			
		]]>
	</fx:Script>
	<fx:Declarations>
		<!-- 将非可视元素（例如服务、值对象）放在此处 -->
	</fx:Declarations>
	<s:BorderContainer id="mSubContainer" width="150" height="180" backgroundColor="#3A9CFF"
					   borderVisible="true" dropShadowVisible="true"
					   middleClick="onPressBtn(event)">
	</s:BorderContainer>
</s:BorderContainer>
