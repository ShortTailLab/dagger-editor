<?xml version="1.0" encoding="utf-8"?>
<s:BorderContainer xmlns:fx="http://ns.adobe.com/mxml/2009"
				   xmlns:s="library://ns.adobe.com/flex/spark"
				   xmlns:mx="library://ns.adobe.com/flex/mx"
				   width="50" height="50" borderVisible="false" initialize="onCreate()"
				   dropShadowVisible="false">
	<fx:Script>
		<![CDATA[
			import behaviorEdit.PathEditPanel;
			
			import manager.EventManager;
			import manager.EventType;
			import manager.GameEvent;
			
			import mx.controls.Alert;
			import mx.managers.PopUpManager;
			
			import spark.components.Group;
			import spark.components.RichEditableText;
			import spark.events.TextOperationEvent;
			import spark.filters.GlowFilter;
			
			private var mCreated:Boolean = false;
			private var mData:Object;
			private var mType:int;
			
			// cache
			private var mMaxDepth:int = -1;
			private var mMaxSiblings:int = -1;
			private var mSiblingIndex:int = -1;
			private var mNodeDepth:int = -1;
			private var mIsInSubTree:int = -1;
			
			// node vars
			private var mNodeVars:Array = [];
			private var mNodeInputs:Array = [];
			
			/** root node, not editable */
			public static const TYPE_ROOT:int = 1;
			/** function node from 6 defined types */
			public static const TYPE_FUNC:int = 3;
			/** editable leaf */
			public static const TYPE_EXEC:int = 4;
			
			
			/** sub bt from other library, not editable */
			public static const TYPE_SUB_BT:int = 2;
			/** detached node */
			public static const TYPE_DETACHED:int = 5;
			
			public static const FUNC_NODE_EXEC:String = "执行";
			public static const FUNC_NODE_SEQ:String = "顺序";
			public static const FUNC_NODE_PRIO:String = "优先";
			public static const FUNC_NODE_SPAWN:String = "同步";
			public static const FUNC_NODE_COND:String = "条件";
			public static const FUNC_NODE_LOOP:String = "循环";
			public static const FUNC_NODE_ONCE:String = "once";
			public static const FUNC_NODE_EVERY:String = "every";
			public static const FUNC_NODE_RANDOM:String = "随机";
			
			public static const ICON_FUNC_NODE:Object = {
				"执行":BTPanel.ICON_EXEC, 
				"顺序":BTPanel.ICON_SEQ, 
				"优先":BTPanel.ICON_PRIO, 
				"同步":BTPanel.ICON_SPAWN,
				"条件":BTPanel.ICON_COND, 
				"循环":BTPanel.ICON_LOOP,
				"once":BTPanel.ICON_ONCE,
				"every":BTPanel.ICON_EVERY,
				"随机":BTPanel.ICON_RANDOM
			};
			
			private var mChildrens:Vector.<BTNode>;
			private var mParent:BTNode;
			private var mCanvas:BT;
			private var mName:String;
			private var mIsSubBT:Boolean = false;
			private var mIsDetached:Boolean = false;
			
			private function onCreate():void {
				trace("created ");
				this.mCreated = true;
				var menu:ContextMenu = new ContextMenu();
				var item0:ContextMenuItem = new ContextMenuItem("更换");
				item0.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onPressBtn);
				menu.addItem(item0);
				var item:ContextMenuItem = new ContextMenuItem("复制");
				item.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onCopyNode);
				menu.addItem(item);
				item = new ContextMenuItem("粘贴");
				item.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onPasteNode);
				menu.addItem(item);
				item = new ContextMenuItem("剪切");
				item.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onCutNode);
				menu.addItem(item);
				var item1:ContextMenuItem = new ContextMenuItem("删除");
				item1.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onDeleteNode);
				menu.addItem(item1);
				var item2:ContextMenuItem = new ContextMenuItem("解锁子行为");
				item2.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onUnlockNode);
				menu.addItem(item2);
				this.mSubContainer.contextMenu = menu;
				
				menu = new ContextMenu();
				item = new ContextMenuItem("更换");
				item.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onPressNext);
				menu.addItem(item);
				item = new ContextMenuItem("粘贴");
				item.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, onPasteNodeToNext);
				menu.addItem(item);
				this.mNext.contextMenu = menu;
				
				this.mBtn.addEventListener(MouseEvent.MOUSE_OVER, onMouseOverNode);
				this.mBtn.addEventListener(MouseEvent.MOUSE_OUT, onMouseOutNode);
				this.mBtn.addEventListener(MouseEvent.CLICK, onMouseClickNode);
				this.mSubContainer.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDownContainer);
				this.mSubContainer.addEventListener(MouseEvent.ROLL_OVER, onMouseOverContainer);
				this.mSubContainer.addEventListener(MouseEvent.ROLL_OUT, onMouseOutContainer);
				this.mNext.addEventListener(MouseEvent.ROLL_OVER, onMouseOverNext);
				this.mNext.addEventListener(MouseEvent.ROLL_OUT, onMouseOutNext);
				
				this.addEventListener(KeyboardEvent.KEY_DOWN, function(evt:KeyboardEvent):void
				{
					evt.stopPropagation();
					evt.stopImmediatePropagation();
				});
				
				if (this.mData) {
					this.updateComponents();
				}
			}
			
			public function getAllChildrens():Array {
				var result:Array = [];
				result.push(this);
				for (var i:int = 0; i < this.mChildrens.length; i++) {
					var r:Array = this.mChildrens[i].getAllChildrens();
					for (var j:int = 0; j < r.length; j++) {
						result.push(r[j]);
					}
				}
				return result;
			}
			
			public var lastMouse:Point;
			private function onMouseDownContainer(event:Event):void {
				if (this.mCanvas.SELECTED_NODE || event.target is RichEditableText) return;
				if (this.mCanvas.CURRENT_EDIT_NODE) {
					this.mCanvas.CURRENT_EDIT_NODE.mSubContainer.filters = [];
				}
				var filter:spark.filters.GlowFilter = new spark.filters.GlowFilter();
				filter.color = 0xFFFF00;
				filter.strength = 50;
				filter.blurX = 20;
				filter.blurY = 20;
				var node:BTNode;
				if (this.isInSubBT()) node = this.rootSubBT;
				else node = this;
				node.mSubContainer.filters = [filter];
				this.mCanvas.CURRENT_EDIT_NODE = node;
				
				if (!this.mParent) return;
				this.mCanvas.DRAGGING_NODES = node.getAllChildrens();
				this.mCanvas.DRAGGING_INFOS = [];
				for each (var n:BTNode in this.mCanvas.DRAGGING_NODES) {
					this.mCanvas.DRAGGING_INFOS.push({x:n.x, y:n.y, index:(n.parent as Group).getChildIndex(n)});
					(n.parent as Group).setElementIndex(n, (n.parent as Group).numElements-1);
//					n.alpha = 0.7;
					n.mSubContainer.removeEventListener(MouseEvent.ROLL_OVER, n.onMouseOverContainer);
					n.mSubContainer.removeEventListener(MouseEvent.ROLL_OUT, n.onMouseOutContainer);
					n.mouseChildren = false;
					n.mouseEnabled = false;
				}
				lastMouse = new Point(this.stage.mouseX, this.stage.mouseY);
				this.stage.addEventListener(MouseEvent.MOUSE_UP, onMouseUpStage);
				this.stage.addEventListener(MouseEvent.MOUSE_MOVE, onMouseMoveStage);
			}
			
			private function onMouseMoveStage(event:MouseEvent):void {
				if (!this.stage) return;
				var p:Point = new Point(this.stage.mouseX, this.stage.mouseY);
				for each (var n:BTNode in this.mCanvas.DRAGGING_NODES) {
					n.x += p.x - lastMouse.x;
					n.y += p.y - lastMouse.y;
				}
				lastMouse = p;
			}
			
			private function onMouseUpStage(event:Event):void {
				this.stage.removeEventListener(MouseEvent.MOUSE_UP, onMouseUpStage);
				this.stage.removeEventListener(MouseEvent.MOUSE_MOVE, onMouseMoveStage);
				var i:int = 0;
				for each (var n:BTNode in this.mCanvas.DRAGGING_NODES) {
					n.stopDrag();
//					n.alpha = 1;
					n.x = this.mCanvas.DRAGGING_INFOS[i].x;
					n.y = this.mCanvas.DRAGGING_INFOS[i].y;
					(n.parent as Group).setElementIndex(n, this.mCanvas.DRAGGING_INFOS[i].index);
					n.mSubContainer.addEventListener(MouseEvent.ROLL_OVER, n.onMouseOverContainer);
					n.mSubContainer.addEventListener(MouseEvent.ROLL_OUT, n.onMouseOutContainer);
					n.mouseChildren = true;
					n.mouseEnabled = true;
					i++;
				}
				var node:BTNode = this.mCanvas.DRAGGING_NODES[0];
				if (this.mCanvas.TARGET_NODE && this.mCanvas.TARGET_TYPE == 1) {
					var tData:Object;
					if (this.mCanvas.TARGET_NODE.isSubBT) {
						tData = {subTree:this.mCanvas.TARGET_NODE.nodeName};
					}
					else {
						tData = Utils.cloneObjectData(this.mCanvas.TARGET_NODE.nodeData);
					}
					var sData:Object;
					if (node.isSubBT) {
						sData = {subTree:node.nodeName};
					}
					else {
						sData = Utils.cloneObjectData(node.nodeData);
					}
					var tName:String = this.mCanvas.TARGET_NODE.nodeName;
					var tIsSubBT:Boolean = this.mCanvas.TARGET_NODE.isSubBT;
					this.mCanvas.TARGET_NODE.mSubContainer.filters = [];
					this.mCanvas.TARGET_NODE.isSubBT = node.isSubBT;
					this.mCanvas.TARGET_NODE.nodeName = node.nodeName;
					this.mCanvas.TARGET_NODE.nodeData = sData;
					this.mCanvas.TARGET_NODE.writeDataBackToParent();
					node.isSubBT = tIsSubBT;
					node.nodeName = tName;
					node.nodeData = tData;
					node.writeDataBackToParent();
					this.mCanvas.updateTree(true);
					this.mCanvas.setModified(true);
				}
				else if (this.mCanvas.TARGET_NODE && this.mCanvas.TARGET_TYPE == 2) {
					this.mCanvas.TARGET_NODE.mNext.filters = [];
					if (node.isSubBT) {
						sData = {subTree:node.nodeName};
					}
					else {
						sData = Utils.cloneObjectData(node.nodeData);
					}
					this.mCanvas.TARGET_NODE.nodeData.children.push(sData);
					this.mCanvas.TARGET_NODE.writeDataBackToParent();
					node.onDeleteNode();
				}
				this.mCanvas.TARGET_NODE = null;
				this.mCanvas.DRAGGING_NODES = null;
				this.mCanvas.DRAGGING_INFOS = null;
			}
			
			public function onMouseOverContainer(event:Event):void {
				if (this.mCanvas.DRAGGING_NODES && this.mCanvas.DRAGGING_NODES[0] != this && !(this.isInSubBT() && this.type != TYPE_ROOT) 
					&& !this.containsChild(this.mCanvas.DRAGGING_NODES[0]) && !this.mCanvas.DRAGGING_NODES[0].containsChild(this)) {
					var filter:spark.filters.GlowFilter = new spark.filters.GlowFilter();
					filter.color = 0x00FF00;
					filter.strength = 50;
					filter.blurX = 20;
					filter.blurY = 20;
					this.mSubContainer.filters = [filter];
					this.mCanvas.TARGET_NODE = this;
					this.mCanvas.TARGET_TYPE = 1;
				}
			}
			
			public function onMouseOutContainer(event:Event):void {
				if (this.mCanvas.DRAGGING_NODES && this.mCanvas.DRAGGING_NODES[0] != this && !(this.isInSubBT() && this.type != TYPE_ROOT) 
					&& !this.containsChild(this.mCanvas.DRAGGING_NODES[0]) && !this.mCanvas.DRAGGING_NODES[0].containsChild(this)) {
					this.mSubContainer.filters = [];
					this.mCanvas.TARGET_NODE = null;
				}
			}
			
			private function onMouseOverNext(event:Event):void {
				if (this.mCanvas.DRAGGING_NODES) {
					var filter:spark.filters.GlowFilter = new spark.filters.GlowFilter();
					filter.color = 0x00FF00;
					filter.strength = 50;
					filter.blurX = 20;
					filter.blurY = 20;
					this.mNext.filters = [filter];
					this.mCanvas.TARGET_NODE = this;
					this.mCanvas.TARGET_TYPE = 2;
				}
			}
			
			private function onMouseOutNext(event:Event):void {
				if (this.mCanvas.DRAGGING_NODES) {
					this.mNext.filters = [];
					this.mCanvas.TARGET_NODE = null;
				}
			}
			
			private function onInput1Click(event:Event):void {
				if (this.isInSubBT()) return;
				var id:String = event.currentTarget.id;
				var index:int = int(id.charAt(id.length-1));
				var data:Object = this.mData.data.parm[index-1];
				
				var window:PathEditPanel = new PathEditPanel(name, data.path, data.type=="array_ccp_curve");
				
				window.addEventListener(MsgEvent.EDIT_PATH, onPathEditPanelClose);
				PopUpManager.addPopUp(window, MapEditor.getInstance(), true);
				PopUpManager.centerPopUp(window);
			}
			
			private function onPathEditPanelClose(e:MsgEvent):void {
				for (var i:int = 1; i < 7; i++) {
					if (this["mVar"+i].text == "path") {
						break;
					}
				}
				this["mInput"+i].text =  JSON.stringify(e.hintData);
				this.mData.data.parm[i-1].path = e.hintData;
				this.writeDataBackToParent();
				this.mCanvas.setModified(true);
			}
			
			private function onMouseOverNode(event:Event):void {
				if (this.mCanvas.SELECTED_NODE && !this.isInSubBT()) {
					var filter:spark.filters.GlowFilter = new spark.filters.GlowFilter();
					filter.color = 0x00FF00;
					filter.strength = 50;
					filter.blurX = 20;
					filter.blurY = 20;
					this.mBtn.filters = [filter];
				}
			}
			
			private function onMouseOutNode(event:Event):void {
				if (this.mCanvas.SELECTED_NODE && !this.isInSubBT()) {
					this.mBtn.filters = [];
				}
			}
			
			private function onMouseClickNode(event:Event):void {
				if (this.mCanvas.SELECTED_NODE && !this.isInSubBT()) {
					var data:Object = {type:this.mCanvas.SELECTED_NODE, data:null, children:[]};
					if (this.mCanvas.SELECTED_NODE == FUNC_NODE_LOOP) {
						data.times = 1;
					}					
					else if (this.mCanvas.SELECTED_NODE == FUNC_NODE_EVERY) {
						data.interval = 0.5;
						data.skip = 0;
					}
					else if (this.mCanvas.SELECTED_NODE == FUNC_NODE_RANDOM) {
						data.weights = [];
					}
					if (this.type == TYPE_ROOT) {
						if (!this.mData.children || this.mData.children.length < 1) {
							if (this.mData.subTree) {
								this.mData.children = [data];
							}
							else {
								this.mData = data;
							}
						}
						else {
							this.mData.children.push(data);
						}
						this.clearChildrens();
					}
					else {
						if (!this.mData.children) {
							this.mData.children = [data];
						}
						else {
							this.mData.children.push(data);
						}
						this.clearChildrens();
						this.writeDataBackToParent();
					}
					this.mCanvas.updateTree(true);
					this.mCanvas.clearSelected();
					this.mCanvas.setModified(true);
					this.mBtn.filters = [];
				}
			}
			
			public function onCopyNode(event:Event=null):void {
				trace(JSON.stringify(this.rootNode.nodeData));
				BTPanel.CLIPPING = Utils.cloneObjectData(this.mData);
				trace("clipping data "+JSON.stringify(this.mData));
			}
			
			public function onDeleteNode(event:Event=null):void {
				if (this.isInSubBT()) {
					var root:BTNode = this.rootSubBT;
					if (root.nodeParent.type == TYPE_ROOT) {
						root.nodeParent.nodeData = {type:"执行", children:[], data:null};
					}
					else {
						var index:int = root.nodeParent.nodeChildrens.indexOf(root);
						root.nodeParent.nodeData.children.splice(index, 1);
					}
					root.nodeParent.writeDataBackToParent();
//					root.nodeParent.updateComponents();
					root.clearChildrens();
					this.mCanvas.removeNodeFromCanvas(root);
				}
				else {
					this.clearChildrens();
					if (this.mParent) {
						this.mCanvas.removeNodeFromCanvas(this);
						if (this.mParent.type == TYPE_ROOT && this.mParent.nodeChildrens.length == 1) {
							this.mParent.nodeData = {type:"执行", children:[], data:null};
						}
						else {
							index = this.mParent.nodeChildrens.indexOf(this);
							this.mParent.nodeData.children.splice(index, 1);
						}
						this.mParent.writeDataBackToParent();
//						this.mParent.updateComponents();
					}
					else {
						this.mData = {type:"执行", children:[], data:null};
//						this.updateComponents();
					}
				}
				this.mCanvas.updateTree(true);
				this.mCanvas.setModified(true);
			}
			
			private function onUnlockNode(event:Event):void {
				var root:BTNode = this.rootSubBT;
				if (!root) {
					Alert.show("节点不在子行为上，无需解锁");
				}
				else {
					if (root.nodeParent.type == TYPE_ROOT) {
						root.nodeParent.nodeData = root.nodeData;
					}
					else {
						var index:int = root.nodeParent.nodeChildrens.indexOf(root);
						root.nodeParent.nodeData.children[index] = root.nodeData;
					}
					root.nodeParent.writeDataBackToParent();
					this.mCanvas.removeNodeFromCanvas(root);
					this.mCanvas.setModified(true);
					this.mCanvas.updateTree(true);
				}
			}
			
			public function onPasteNode(event:Event=null):void {
				if (BTPanel.CLIPPING) {
					var clipping:Object = Utils.cloneObjectData(BTPanel.CLIPPING);
					if (this.isInSubBT()) {
						if (this.type == TYPE_ROOT) {
							this.mCanvas.setModified(true);
							if (this.mParent.type == TYPE_ROOT) {
								this.mParent.nodeData = clipping;
								this.mParent.clearChildrens();
							}
							else {
								var index:int = this.mParent.mChildrens.indexOf(this);
								this.mParent.nodeData.children[index] = clipping;
							}
							this.mParent.writeDataBackToParent();
//							this.mParent.updateComponents();
							this.mCanvas.updateTree(true);
						}
					}
					else {
						this.mCanvas.setModified(true);
						if (!this.mParent) {
							this.mData = clipping;
							this.clearChildrens();
//							this.updateComponents();
						}
						else {
							if (this.mParent.type == TYPE_ROOT) {
								this.mParent.nodeData = clipping;
								this.mParent.clearChildrens();
							}
							else {
								index = this.mParent.mChildrens.indexOf(this);
								this.mParent.nodeData.children[index] = clipping;
							}
							this.mParent.writeDataBackToParent();
//							this.mParent.updateComponents();
						}
						this.mCanvas.updateTree(true);
					}
				}
			}
			
			public function onCutNode(event:Event=null):void {
				this.onCopyNode(event);
				this.onDeleteNode(event);
			}
			
			private function onPasteNodeToNext(event:Event):void {
				if (BTPanel.CLIPPING) {
					var clipping:Object = Utils.cloneObjectData(BTPanel.CLIPPING);
					if (this.type == TYPE_ROOT) {
						this.mData = clipping;
					}
					else {
						this.mData.children.push(clipping);
					}
					this.writeDataBackToParent();
					this.mCanvas.setModified(true);
//					this.updateComponents();
					this.mCanvas.updateTree(true);
				}
			}
			
			public function setData(type:int, name:String, data:Object, canvas:BT, parent:BTNode=null):void {
				this.mType = type;
				this.mData = data;
				this.mCanvas = canvas;
				this.mParent = parent;
				this.mName = name;
				
				if (this.mCreated) {
					this.updateComponents();
				}
				this.updateChildrens();
			}
			
			public function updateComponents():void {
//				trace("name "+this.mName+" depth "+this.nodeDepth+" siblingIndex "+this.siblingIndex);
				var i:int;
				var j:int;
				var hasNextNode:Boolean = false;
				var numParams:int;
				this.toolTip = "";
				for (i = 0; i < this.mNodeVars.length; i++) {
					this.removeElement(this.mNodeVars[i]);
					this.removeElement(this.mNodeInputs[i]);
					this.mNodeInputs[i].removeEventListener(TextOperationEvent.CHANGE, onValueChanged);
				}
				this.mNodeVars.length = 0;
				this.mNodeInputs.length = 0;
				switch (this.mType) {
					case TYPE_ROOT:
						this.mBtn.visible = true;
						this.mBtn.setStyle("icon", this.isSubBT?new BTPanel.ICON_SUBTREE():new BTPanel.ICON_ROOT());
						this.mSubContainer.width = this.mSubContainer.height = 50;
						for (i = 1; i < 7; i++) {
							this["mVar"+i].visible = false;
							this["mInput"+i].visible = false;
						}
						this.mTitle.visible = false;
//						if (!this.mData.children || (!this.mData.data && this.mData.children.length == 0 && !this.mData.type)) {
//							this.mNextLine.visible = true;
//							this.mNext.visible = true;
//							this.mNextLine.x = 50;
//							this.mNext.x = 100;
//						}
//						else {
							this.mNextLine.visible = false;
							this.mNext.visible = false;
//						}
						break;
					case TYPE_FUNC: 
						if (this.mName == FUNC_NODE_EXEC) {
							// empty node
							if (this.mData.args || !this.mData.data) {
								this.mBtn.visible = true;
								this.mBtn.setStyle("icon", new ICON_FUNC_NODE[this.mName]());
								this.mSubContainer.width = this.mSubContainer.height = 50;
								for (i = 1; i < 7; i++) {
									this["mVar"+i].visible = false;
									this["mInput"+i].visible = false;
								}
								this.mTitle.visible = false;
								this.mNext.visible = false;
								this.mNextLine.visible = false;
							}
							// contains children, replace it
							else {
								for each (var d:Object in Data.getInstance().behaviorNodes) {
									if (d.func == this.mData.data.execType) {
										this.toolTip = d.desc;
										break;
									}
								}
								this.mBtn.visible = false;
								this.mTitle.visible = true;
								this.mTitle.text = this.mData.data.execType.substr(8);
								hasNextNode = false;
								j = 1;
								for (i = 0; i < this.mData.data.parm.length; i++) {
									if (this.mData.data.parm[i].type == "node") {
										hasNextNode = true;
									}
									else {
										this["mVar"+j].visible = true;
										this["mInput"+j].visible = true;
										this["mVar"+j].text = this.mData.data.parm[i].name;
										this["mInput"+j].text = this.mData.data.parm[i].value || JSON.stringify(this.mData.data.parm[i].path);
										if (this.mData.data.parm[i].path) {
											this["mInput"+j].addEventListener(MouseEvent.CLICK, onInput1Click);
										}
										else {
											this["mInput"+j].removeEventListener(MouseEvent.CLICK, onInput1Click);
										}
										(this["mInput"+j] as TextInput).editable = !this.isInSubBT();
										j++;
									}
								}
								numParams = j;
								for (; j < 7; j++) {
									this["mVar"+j].visible = false;
									this["mInput"+j].visible = false;
								}
								if (hasNextNode && (!this.mData.children || this.mData.children.length < 1)) {
									this.mNext.visible = true;
									this.mNextLine.visible = true;
									this.mNextLine.x = 150;
									this.mNext.x = 200;
								}
								else {
									this.mNext.visible = false;
									this.mNextLine.visible = false;
								}
								this.mSubContainer.width = 150;
								numParams = numParams<2?2:numParams;
								this.mSubContainer.height = 185-(7-numParams)*25;
							}
						}
						else {
							if (this.mName == FUNC_NODE_LOOP) {
								var label:Label = new Label();
								this.addElement(label);
								label.id = "mNodeVar1"; label.x = -25; label.y = 55; label.width = 50; label.text = "loop";
								label.setStyle("fontSize", 14); label.setStyle("textAlign", "right"); label.setStyle("verticalAlign", "middle");
								this.mNodeVars.push(label);
								var input:TextInput = new TextInput();
								this.addElement(input);
								input.id = "mNodeInput1"; input.x = 25; input.y = 52; input.width = 40; input.height = 18;
								input.setStyle("fontSize", 11); input.setStyle("textAlign", "center");
								this.mNodeInputs.push(input);
								input.addEventListener(TextOperationEvent.CHANGE, onValueChanged);
								if (this.mData.times) {
									input.text = this.mData.times;
								}
								input.editable = !this.isInSubBT();
							}
							else if (this.mName == FUNC_NODE_EVERY) {
								label = new Label();
								this.addElement(label);
								label.id = "mNodeVar1"; label.x = -25; label.y = 55; label.width = 50; label.text = "inteval";
								label.setStyle("fontSize", 14); label.setStyle("textAlign", "right"); label.setStyle("verticalAlign", "middle");
								this.mNodeVars.push(label);
								input = new TextInput();
								this.addElement(input);
								input.id = "mNodeInput1"; input.x = 25; input.y = 52; input.width = 40; input.height = 18;
								input.setStyle("fontSize", 11); input.setStyle("textAlign", "center");
								this.mNodeInputs.push(input);
								input.addEventListener(TextOperationEvent.CHANGE, onValueChanged);
								if (this.mData.interval) {
									input.text = this.mData.interval;
								}
								input.editable = !this.isInSubBT();
								
								label = new Label();
								this.addElement(label);
								label.id = "mNodeVar2"; label.x = -25; label.y = 75; label.width = 50; label.text = "skip";
								label.setStyle("fontSize", 14); label.setStyle("textAlign", "right"); label.setStyle("verticalAlign", "middle");
								this.mNodeVars.push(label);
								input = new TextInput();
								this.addElement(input);
								input.id = "mNodeInput2"; input.x = 25; input.y = 72; input.width = 40; input.height = 18;
								input.setStyle("fontSize", 11); input.setStyle("textAlign", "center");
								this.mNodeInputs.push(input);
								input.addEventListener(TextOperationEvent.CHANGE, onValueChanged);
								if (this.mData.hasOwnProperty("skip")) {
									input.text = this.mData.skip;
								}
								input.editable = !this.isInSubBT();
							}
							else if (this.mName == FUNC_NODE_RANDOM) {
								for (i = 0; i < this.mData.children.length; i++) {
									label = new Label();
									this.addElement(label);
									label.id = "mNodeVar"+(i+1); label.x = -25; label.y = 55+i*20; label.width = 50; label.text = "weight"; 
									label.setStyle("fontSize", 14); label.setStyle("textAlign", "right"); label.setStyle("verticalAlign", "middle");
									this.mNodeVars.push(label);
									input = new TextInput();
									this.addElement(input);
									input.id = "mNodeInput"+(i+1); input.x = 25; input.y = 52+i*20; input.width = 40; input.height = 18;
									input.setStyle("fontSize", 11); input.setStyle("textAlign", "center");
									this.mNodeInputs.push(input);
									input.addEventListener(TextOperationEvent.CHANGE, onValueChanged);
									if (this.mData.weights.length > i) {
										input.text = this.mData.weights[i];
									}
									input.editable = !this.isInSubBT();
								}
							}
							
							this.mBtn.visible = true;
							this.mBtn.setStyle("icon", new ICON_FUNC_NODE[this.mName]());
							this.mSubContainer.width = this.mSubContainer.height = 50;
							for (i = 1; i < 7; i++) {
								this["mVar"+i].visible = false;
								this["mInput"+i].visible = false;
							}
//							if (this.mData.children && this.mData.children.length > 0) {
								this.mNext.visible = false;
								this.mNextLine.visible = false;
//							}
//							else {
//								this.mNext.visible = true;
//								this.mNextLine.visible = true;
//								this.mNextLine.x = 50;
//								this.mNext.x = 100;
//							}
							this.mTitle.visible = false;
						}
						break;
					case TYPE_EXEC:
						for each (d in Data.getInstance().behaviorNodes) {
							if (d.func == this.mData.data.execType) {
								this.toolTip = d.desc;
								break;
							}
						}
						this.mBtn.visible = false;
						this.mTitle.visible = true;
						this.mTitle.text = this.mName.substr(8);
						hasNextNode = false;
						j = 1;
						var params:Object = this.mData.data.parm;
						for (i = 0; i < params.length; i++) {
							if (params[i].type == "node") {
								hasNextNode = true;
							}
							else {
								this["mVar"+j].visible = true;
								this["mInput"+j].visible = true;
								this["mVar"+j].text = params[i].name;
								this["mInput"+j].text = params[i].value || JSON.stringify(params[i].path);
								if (params[i].path) {
									this["mInput"+j].addEventListener(MouseEvent.CLICK, onInput1Click);
								}
								else {
									this["mInput"+j].removeEventListener(MouseEvent.CLICK, onInput1Click);
								}
								(this["mInput"+j] as TextInput).editable = !this.isInSubBT();
								j++;
							}
						}
						numParams = j;
						for (; j < 7; j++) {
							this["mVar"+j].visible = false;
							this["mInput"+j].visible = false;
						}
						if (hasNextNode && (this.mData.args || !this.mData.children || this.mData.children.length < 1)) {
							this.mNext.visible = true;
							this.mNextLine.visible = true;
							this.mNextLine.x = 150;
							this.mNext.x = 200;
						}
						else {
							this.mNext.visible = false;
							this.mNextLine.visible = false;
						}
						this.mSubContainer.width = 150;
						this.mSubContainer.height = 185-(7-numParams)*25;
						break;
				}
//				this.updateChildrens();
			}
			
			public function clearChildrens():void {
				if (this.mChildrens) {
					for (var i:int = 0; i < this.mChildrens.length; i++) {
						this.mChildrens[i].mCanvas.removeNodeFromCanvas(this.mChildrens[i]);
						this.mChildrens[i].clearChildrens();
					}
				}
				else {
					this.mChildrens = new Vector.<BTNode>();
				}
				this.mChildrens.length = 0;
			}
			
			private function updateChildrens():void {
				this.clearChildrens();
				var child:BTNode;
				switch (this.mType) {
					case TYPE_ROOT:
						if (this.mData.type) {
							child = BT.POOL_POP();
							this.mChildrens.push(child);
							child.setData(TYPE_FUNC, this.mData.type, this.mData, this.mCanvas, this);
							this.mCanvas.addNodeToCanvas(child);
						}
						else if (this.mData.subTree) {
							child = BT.POOL_POP();
							this.mChildrens.push(child);
							var subTreeData:Object = Utils.cloneObjectData(Data.getInstance().behaviorSet[this.mData.subTree]);
							child.isSubBT = true;
							child.setData(TYPE_ROOT, this.mData.subTree, subTreeData, this.mCanvas, this);
							this.mCanvas.addNodeToCanvas(child);
						}
						else if (this.mData.execType) {
							// error
						}
						break;
					case TYPE_FUNC:
						for each (var data:Object in this.mData.children) {
							child = BT.POOL_POP();
							this.mChildrens.push(child);
							if (data.type) {
								child.setData(TYPE_FUNC, data.type, data, this.mCanvas, this);
							}
							else if (data.subTree) {
								subTreeData = Utils.cloneObjectData(Data.getInstance().behaviorSet[data.subTree]);
								child.isSubBT = true;
								child.setData(TYPE_ROOT, data.subTree, subTreeData, this.mCanvas, this);
							}
							else if (data.execType) {
								// error
							}
							this.mCanvas.addNodeToCanvas(child);
						}
						break;
				}
			}
			
			private function onBtnIconLoad(event:Event):void {
				var bmpData:BitmapData = event.currentTarget.content.bitmapData;
				this.mBtn.setStyle("icon", bmpData);
			}
			
			private function onPressBtn(event:Event):void {
				if (this.mType == TYPE_ROOT && !this.isInSubBT()) return;
				if (this.mType != TYPE_ROOT && this.isInSubBT()) {
					Alert.show("子行为已锁定，解锁后可编辑");
					return;
				}
				
				EventManager.getInstance().addEventListener(EventType.BT_NODE_SELECTION_COMPLETE, onNodeSelected);
				var selection:BTNodeSelection = new BTNodeSelection();
				PopUpManager.addPopUp(selection, MapEditor.getInstance(), true);
				PopUpManager.centerPopUp(selection);
			}
			
			private function onNodeSelected(event:GameEvent):void {
				EventManager.getInstance().removeEventListener(EventType.BT_NODE_SELECTION_COMPLETE, onNodeSelected);
				if (!event.data) return;
				
				// change current node
				var newData:Object;
				switch (event.data.type) {
					case TYPE_EXEC:
//						if (this.isSubBT) {
							this.clearChildrens();
							this.mData.children = [];
//						}
						this.isSubBT = false;
						newData = {type:"执行", children:this.mData.children, data:{execType:event.data.name.func, parm:[]}};
						for (var i:int = 0; i < event.data.name.args.length; i++) {
							if (event.data.name.args[i].type == "ccp") {
								newData.data.parm.push({type:"ccp", name:"x", value:"float"});
								newData.data.parm.push({type:"ccp", name:"y", value:"float"});
							}
							else if (event.data.name.args[i].type == "ccsize") {
								newData.data.parm.push({type:"ccsize", name:"width", value:"float"});
								newData.data.parm.push({type:"ccsize", name:"height", value:"float"});
							}
							else {
								if (event.data.name.args[i].name == "path") {
									event.data.name.args[i].path = [];
								}
								else {
									event.data.name.args[i].value = event.data.name.args[i].type;
								}
								newData.data.parm.push(event.data.name.args[i]);
							}
						}
						this.setData(TYPE_EXEC, event.data.name.func, newData, this.mCanvas, this.mParent);
						break;
					case TYPE_FUNC:
						if (this.isSubBT) {
							this.clearChildrens();
							this.mData.children = [];
						}
						this.isSubBT = false;
						newData = {type:event.data.name, data:null, children:this.mData.children};
						if (event.data.name == FUNC_NODE_LOOP) {
							newData.times = 1;
						}
						else if (event.data.name == FUNC_NODE_EVERY) {
							newData.interval = 0.5;
							newData.skip = 0;
						}
						else if (event.data.name == FUNC_NODE_RANDOM) {
							newData.weights = [];
							for (i = 0; i < this.mData.children.length; i++) {
								newData.weights.push(1);
							}
						}
						this.setData(TYPE_FUNC, event.data.name, newData, this.mCanvas, this.mParent);
						break;
					case TYPE_SUB_BT:
						if (event.data.name == this.rootNode.nodeName) {
							Alert.show("不能递归嵌套行为！");
							return;
						}
						this.isSubBT = true;
						this.clearChildrens();
						newData = Utils.cloneObjectData(Data.getInstance().behaviorSet[event.data.name]);;
						this.setData(TYPE_ROOT, event.data.name, newData, this.mCanvas, this.mParent);
						break;
				}
				this.writeDataBackToParent();
				this.mCanvas.setModified(true);
				this.mCanvas.updateTree(true);
			}
			
			public function writeDataBackToParent():void {
				if (this.mName == FUNC_NODE_RANDOM) {
					for (var i:int = 0; i < this.mData.children.length; i++) {
						if (this.mData.weights.length <= i) {
							this.mData.weights.push(1);
						}
					}
				}
				if (this.mParent) {
					if (this.isSubBT) {
						if (this.mParent.type == TYPE_ROOT) {
							this.mParent.nodeData = {subTree:this.mName};
						}
						else {
							var index:int = this.mParent.nodeChildrens.indexOf(this);
							this.mParent.nodeData.children[index] = {subTree:this.mName};
						}
					}
					else if (this.mParent.type != TYPE_ROOT) {
						index = this.mParent.nodeChildrens.indexOf(this);
						this.mParent.nodeData.children[index] = this.mData;
						this.mParent.writeDataBackToParent();
					}
					else {
						this.mParent.nodeData = this.mData;
					}
				}
				else {
					this.mCanvas.data[0] = this.mData;
				}
			}
			
			private function onPressNext(event:Event):void {
				if (this.isInSubBT()) return;
				
				EventManager.getInstance().addEventListener(EventType.BT_NODE_SELECTION_COMPLETE, onNextNodeSelected);
				var selection:BTNodeSelection = new BTNodeSelection();
				PopUpManager.addPopUp(selection, MapEditor.getInstance(), true);
				PopUpManager.centerPopUp(selection);
			}
			
			private function onNextNodeSelected(event:GameEvent):void {
				EventManager.getInstance().removeEventListener(EventType.BT_NODE_SELECTION_COMPLETE, onNextNodeSelected);
				if (!event.data) return;
				
				this.mData.children = [];
				var newData:Object;
				switch (event.data.type) {
					case TYPE_EXEC:
						newData = {type:"执行", children:[], data:{execType:event.data.name.func, parm:[]}};
						for (var i:int = 0; i < event.data.name.args.length; i++) {
							if (event.data.name.args[i].type == "ccp") {
								newData.data.parm.push({type:"ccp", name:"dir x", value:"float"});
								newData.data.parm.push({type:"ccp", name:"dir y", value:"float"});
							}
							else if (event.data.name.args[i].type == "ccsize") {
								newData.data.parm.push({type:"ccsize", name:"width", value:"float"});
								newData.data.parm.push({type:"ccsize", name:"height", value:"float"});
							}
							else {
								if (event.data.name.args[i].name == "path") {
									event.data.name.args[i].path = [];
								}
								else {
									event.data.name.args[i].value = event.data.name.args[i].type;
								}
								newData.data.parm.push(event.data.name.args[i]);
							}
						}
						if (this.type == TYPE_ROOT) {
							this.mData = newData;
						}
						else {
							this.mData.children.push(newData);
						}
						break;
					case TYPE_FUNC:
						newData = {type:event.data.name, data:null, children:[]};
						if (event.data.name == FUNC_NODE_LOOP) {
							newData.times = 1;
						}
						else if (event.data.name == FUNC_NODE_EVERY) {
							newData.interval = 0.5;
							newData.skip = 0;
						}
						else if (event.data.name == FUNC_NODE_RANDOM) {
							newData.weights = [];
							for (i = 0; i < this.mData.children.length; i++) {
								newData.weights.push(1);
							}
						}
						if (this.type == TYPE_ROOT) {
							this.mData = newData;
						}
						else {
							this.mData.children.push(newData);
						}
						break;
					case TYPE_SUB_BT:
						this.mData.children.push({subTree:event.data.name});
						break;
				}
				this.writeDataBackToParent();
				this.mCanvas.setModified(true);
				this.mCanvas.updateTree(true);
			}
			
			private function onValueChanged(event:TextOperationEvent):void {
				var id:String = event.currentTarget.id;
				if (id.indexOf("mNodeInput") != -1) {
					if (this.mName == FUNC_NODE_LOOP) {
						this.mData.times = (event.currentTarget as TextInput).text;
					}
					else if (this.mName == FUNC_NODE_EVERY) {
						if (id == "mNodeInput1") {
							this.mData.interval = (event.currentTarget as TextInput).text;
						}
						else if (id == "mNodeInput2") {
							this.mData.skip = (event.currentTarget as TextInput).text;
						}
					}
					else if (this.mName == FUNC_NODE_RANDOM) {
						var index:int = Utils.getLastInt(id);
						this.mData.weights[index-1] = (event.currentTarget as TextInput).text;
					}
				}
				else {
					index = int(id.charAt(id.length-1));
					this.mData.data.parm[index-1].value = (event.currentTarget as TextInput).text;
				}
				this.writeDataBackToParent();
				this.mCanvas.setModified(true);
			}
			
			public function reset():void {
				this.mMaxDepth = -1;
				this.mMaxSiblings = -1;
				this.mSiblingIndex = -1;
				this.mNodeDepth = -1;
				this.mIsInSubTree = -1;
				this.mIsSubBT = false;
			}
			
			public function isInSubBT():Boolean {
				if (this.mIsInSubTree != -1) return this.mIsInSubTree==1;
				if (this.mIsSubBT) {
					this.mIsInSubTree = 1;
					return true;
				}
				if (this.mParent) {
					this.mIsInSubTree = this.mParent.isInSubBT()?1:0;
					return this.mIsInSubTree==1;
				}
				this.mIsInSubTree = 0;
				return this.mIsInSubTree==1;
			}
			
			public function containsChild(node:BTNode):Boolean {
				if (this == node) return true;
				for each (var child:BTNode in this.mChildrens) {
					if (child == node) return true;
					var r:Boolean = child.containsChild(node);
					if (r) return r;
				}
				return false;
			}
			
			public function get nodeDepth():int {
				if (this.mNodeDepth != -1) return this.mNodeDepth;
				var depth:int = 0;
				var p:BTNode = this.mParent;
				while (p) {
					depth++;
					p = p.nodeParent;
				}
				this.mNodeDepth = depth;
				return depth;
			}
			
			public function get siblingIndex():int {
				if (this.mSiblingIndex != -1) return this.mSiblingIndex;
				if (this.mParent) { 
					var index:int = this.mParent.nodeChildrens.indexOf(this);
					if (index <= 0) {
						this.mSiblingIndex = this.mParent.siblingIndex;
						return this.mSiblingIndex;
					}
					else {
						this.mSiblingIndex = this.mParent.nodeChildrens[index-1].maxSiblings + this.mParent.nodeChildrens[index-1].siblingIndex;
						return this.mSiblingIndex;
					}
				}
				this.mSiblingIndex = 0;
				return 0;
			}
			
			/** max depth count from current node */
			public function get maxDepth():int {
				if (this.mMaxDepth != -1) return this.mMaxDepth; 
				if (this.mChildrens.length <= 0) return 1;
				var max:int = 1;
				for (var i:int = 0; i < this.mChildrens.length; i++) {
					var depth:int = this.mChildrens[i].maxDepth;
					if (depth > max) {
						max = depth;
					}
				}
				this.mMaxDepth = max+1;
				return max+1;
			}
			
			public function get maxSiblings():int {
				if (this.mMaxSiblings != -1) return this.mMaxSiblings; 
				if (!this.mChildrens || this.mChildrens.length <= 0) return 1;
				var max:int = 0;
				for (var i:int = 0; i < this.mChildrens.length; i++) {
					var s:int = this.mChildrens[i].maxSiblings;
					max += s;
				}
				this.mMaxSiblings = max;
				return max;
			}
			
			public function get rootNode():BTNode {
				if (this.mParent) {
					return this.mParent.rootNode;
				}
				return this;
			}
			
			public function get rootSubBT():BTNode {
				if (!this.mParent) {
					return null;
				}
				if (this.isSubBT && this.type == TYPE_ROOT) {
					return this;
				}
				return this.mParent.rootSubBT;
			}
			
			public function get nodeWidth():Number {
//				if (this.mName == FUNC_NODE_LOOP || this.mName == FUNC_NODE_EVERY || this.mName == FUNC_NODE_RANDOM) {
//					return this.mSubContainer.width+20;
//				}
				return this.mSubContainer.width;
			}
			
			public function get nodeHeight():Number {
				if (this.mName == FUNC_NODE_LOOP) {
					return this.mSubContainer.height+20;
				}
				else if (this.mName == FUNC_NODE_EVERY) {
					return this.mSubContainer.height+40;
				}
				else if (this.mName == FUNC_NODE_RANDOM) {
					return this.mSubContainer.height+20*this.mData.weights.length;
				}
				return this.mSubContainer.height;
			}
			
			public function get type():int { return this.mType; }
			public function get nodeParent():BTNode { return this.mParent; }
			public function get nodeChildrens():Vector.<BTNode> { return this.mChildrens; }
			public function get nodeName():String { return this.mName; }
			public function set nodeName(value:String):void { this.mName = value; }
			public function get nodeData():Object { return this.mData; }
			public function set nodeData(value:Object):void { this.mData = value; }
			public function get isSubBT():Boolean { return this.mIsSubBT};
			public function set isSubBT(value:Boolean):void { this.mIsSubBT = value; }
			public function get isDetached():Boolean { return this.mIsDetached};
			public function set isDetached(value:Boolean):void { this.isDetached = value; }
			
		]]>
	</fx:Script>
	<fx:Declarations>
		<!-- 将非可视元素（例如服务、值对象）放在此处 -->
	</fx:Declarations>
	<s:BorderContainer id="mSubContainer" width="150" height="180" backgroundColor="#3A9CFF"
					   borderVisible="true" dropShadowVisible="true"
					   middleClick="onPressBtn(event)">
		<s:Button id="mBtn" width="50" height="50" 
				  cornerRadius="0" fontFamily="Arial" fontStyle="normal" fontWeight="normal"
				  icon="assets/zhixing.png"/>
		<s:Label id="mTitle" x="0" y="0" width="100%" color="#FFFFFF" fontSize="12" text="StayOnMap"
				 textAlign="center" verticalAlign="middle"/>
		<s:Label id="mVar1" x="0" y="30" width="50%" color="#FFFFFF" fontSize="14" text="variable1:"
				 textAlign="center" verticalAlign="middle"/>
		<s:Label id="mVar2" x="0" y="55" width="50%" color="#FFFFFF" fontSize="14" text="variable1:"
				 textAlign="center" verticalAlign="middle"/>
		<s:TextInput id="mInput1" x="75" y="25" width="50%" change="onValueChanged(event)"
					 textAlign="center"/>
		<s:TextInput id="mInput2" x="75" y="50" width="50%" change="onValueChanged(event)"
					 textAlign="center"/>
		<s:TextInput id="mInput3" x="75" y="75" width="50%" change="onValueChanged(event)"
					 textAlign="center"/>
		<s:TextInput id="mInput4" x="75" y="100" width="50%" change="onValueChanged(event)"
					 textAlign="center"/>
		<s:TextInput id="mInput5" x="75" y="125" width="50%" change="onValueChanged(event)"
					 textAlign="center"/>
		<s:TextInput id="mInput6" x="75" y="150" width="50%" change="onValueChanged(event)"
					 textAlign="center"/>
		<s:Label id="mVar3" x="0" y="80" width="50%" color="#FFFFFF" fontSize="14" text="variable1:"
				 textAlign="center" verticalAlign="middle"/>
		<s:Label id="mVar4" x="0" y="105" width="50%" color="#FFFFFF" fontSize="14" text="variable1:"
				 textAlign="center" verticalAlign="middle"/>
		<s:Label id="mVar5" x="0" y="130" width="50%" color="#FFFFFF" fontSize="14" text="variable1:"
				 textAlign="center" verticalAlign="middle"/>
		<s:Label id="mVar6" x="0" y="155" width="50%" color="#FFFFFF" fontSize="14" text="variable1:"
				 textAlign="center" verticalAlign="middle"/>
	</s:BorderContainer>
	<s:Button id="mNext" x="200" y="0" width="50" height="50" label="可接节点" 
			  click="onPressNext(event)" middleClick="onPressNext(event)" cornerRadius="0" fontFamily="Arial" fontStyle="normal"
			  fontWeight="normal" icon="@Embed('assets/zhixing.png')"/>
	<mx:HRule id="mNextLine" x="150" y="25" width="50"/>
</s:BorderContainer>
